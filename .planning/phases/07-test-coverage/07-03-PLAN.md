---
phase: 07-test-coverage
plan: 03
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - tests/integration/mcp/jsonrpc-protocol.test.ts
  - tests/setup/global-setup.ts
  - docker-compose.test.yml
autonomous: true

must_haves:
  truths:
    - "JSON-RPC responses comply with 2.0 specification"
    - "MCP server responds to tools/list with correct format"
    - "Error responses have proper code and message fields"
    - "Integration tests use real Qdrant via testcontainers"
  artifacts:
    - path: "tests/integration/mcp/jsonrpc-protocol.test.ts"
      provides: "JSON-RPC 2.0 compliance tests"
      contains: "describe.*JSON-RPC"
    - path: "tests/setup/global-setup.ts"
      provides: "Container lifecycle management"
      exports: ["setup", "teardown"]
    - path: "docker-compose.test.yml"
      provides: "Test environment configuration"
      contains: "qdrant"
  key_links:
    - from: "tests/integration/mcp/jsonrpc-protocol.test.ts"
      to: "tests/setup/global-setup.ts"
      via: "globalSetup config"
      pattern: "globalSetup"
---

<objective>
Create integration tests for JSON-RPC protocol compliance using spawned MCP server.

Purpose: Satisfy TST-03 (integration tests for JSON-RPC protocol compliance) by testing real protocol interactions.
Output: Integration tests verifying JSON-RPC 2.0 compliance, proper MCP tool registration, and error handling.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-test-coverage/07-RESEARCH.md
@.planning/phases/07-test-coverage/07-01-SUMMARY.md
@src/rlm/mcp/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create global setup for container lifecycle</name>
  <files>tests/setup/global-setup.ts, docker-compose.test.yml, vitest.config.ts</files>
  <action>
Create docker-compose.test.yml for test environment:
```yaml
services:
  qdrant:
    image: qdrant/qdrant:v1.13.1
    ports:
      - "6333:6333"
    environment:
      - QDRANT__SERVICE__GRPC_PORT=6334
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:6333/readiness"]
      interval: 5s
      timeout: 5s
      retries: 5
```

Create tests/setup/global-setup.ts using @testcontainers/qdrant:
```typescript
import { QdrantContainer, StartedQdrantContainer } from '@testcontainers/qdrant';

let container: StartedQdrantContainer | undefined;

export async function setup() {
  // Start Qdrant container for integration tests
  container = await new QdrantContainer('qdrant/qdrant:v1.13.1').start();

  // Make URL available to tests via environment variable
  process.env.QDRANT_URL = container.getRestHostAddress();
  console.log(`Qdrant started at ${process.env.QDRANT_URL}`);
}

export async function teardown() {
  if (container) {
    await container.stop();
    console.log('Qdrant container stopped');
  }
}
```

Update vitest.config.ts to add integration test configuration:
- Add globalSetup for integration tests
- Configure separate test runs for unit vs integration
- Set longer timeout for integration tests (60s)

Add to vitest.config.ts:
```typescript
// Integration test project
{
  test: {
    name: 'integration',
    include: ['tests/integration/**/*.test.ts'],
    globalSetup: './tests/setup/global-setup.ts',
    testTimeout: 60000,
    hookTimeout: 120000, // Container startup can be slow
  }
}
```
  </action>
  <verify>
docker-compose.test.yml is valid YAML.
tests/setup/global-setup.ts compiles without errors.
vitest.config.ts includes integration project configuration.
  </verify>
  <done>Global setup for testcontainers configured. Container starts before integration tests, stops after.</done>
</task>

<task type="auto">
  <name>Task 2: Create JSON-RPC protocol compliance tests</name>
  <files>tests/integration/mcp/jsonrpc-protocol.test.ts</files>
  <action>
Create tests/integration/mcp/ directory.

Create jsonrpc-protocol.test.ts with compliance tests:

```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { spawn, ChildProcess } from 'child_process';
import { join } from 'path';

describe('JSON-RPC 2.0 Protocol Compliance', () => {
  let server: ChildProcess;
  let requestId = 0;

  const sendRequest = (method: string, params: object = {}): Promise<any> => {
    // Implementation from research - send JSON-RPC request, parse response
  };

  beforeAll(async () => {
    // Build first to ensure dist is up to date
    // Spawn MCP server
    server = spawn('node', [join(__dirname, '../../../dist/rlm/mcp/server.js')], {
      stdio: ['pipe', 'pipe', 'pipe'],
      env: { ...process.env }
    });

    // Wait for server to be ready (check stderr for startup log)
    await new Promise(resolve => setTimeout(resolve, 1000));
  });

  afterAll(() => {
    server.kill('SIGTERM');
  });

  // Core JSON-RPC 2.0 compliance
  it('includes jsonrpc version "2.0" in response', async () => {
    const response = await sendRequest('tools/list');
    expect(response.jsonrpc).toBe('2.0');
  });

  it('echoes request id in response', async () => {
    const response = await sendRequest('tools/list');
    expect(response.id).toBeDefined();
  });

  it('response has result OR error, not both', async () => {
    const response = await sendRequest('tools/list');
    const hasResult = 'result' in response;
    const hasError = 'error' in response;
    expect(hasResult || hasError).toBe(true);
    expect(hasResult && hasError).toBe(false);
  });

  // MCP-specific compliance
  it('tools/list returns array of tools', async () => {
    const response = await sendRequest('tools/list');
    expect(response.result).toHaveProperty('tools');
    expect(Array.isArray(response.result.tools)).toBe(true);
  });

  it('tools/list includes search_code, index_code, get_status', async () => {
    const response = await sendRequest('tools/list');
    const toolNames = response.result.tools.map((t: any) => t.name);
    expect(toolNames).toContain('search_code');
    expect(toolNames).toContain('index_code');
    expect(toolNames).toContain('get_status');
  });

  it('each tool has name, description, inputSchema', async () => {
    const response = await sendRequest('tools/list');
    for (const tool of response.result.tools) {
      expect(tool).toHaveProperty('name');
      expect(tool).toHaveProperty('description');
      expect(tool).toHaveProperty('inputSchema');
    }
  });

  // Error handling
  it('returns error object for invalid method', async () => {
    const response = await sendRequest('invalid/nonexistent');
    expect(response).toHaveProperty('error');
    expect(response.error).toHaveProperty('code');
    expect(response.error).toHaveProperty('message');
  });

  it('error code is integer', async () => {
    const response = await sendRequest('invalid/nonexistent');
    expect(Number.isInteger(response.error.code)).toBe(true);
  });

  // Stdout/stderr separation
  it('stdout contains only JSON-RPC responses', async () => {
    // Verify no log pollution in stdout
    const response = await sendRequest('tools/list');
    expect(() => JSON.parse(JSON.stringify(response))).not.toThrow();
  });
});
```
  </action>
  <verify>
npm run test -- tests/integration/mcp/jsonrpc-protocol.test.ts passes (requires Qdrant running).
All JSON-RPC 2.0 compliance checks pass.
  </verify>
  <done>JSON-RPC protocol compliance tests created and passing.</done>
</task>

<task type="auto">
  <name>Task 3: Add npm scripts for integration tests</name>
  <files>package.json</files>
  <action>
Add integration test scripts to package.json:
```json
"test:unit": "vitest run --project unit",
"test:integration": "vitest run --project integration",
"test:all": "vitest run"
```

Update vitest.config.ts to define workspace projects:
- unit: tests/unit/**/*.test.ts (fast, no containers)
- integration: tests/integration/**/*.test.ts (with globalSetup)

This allows running:
- `npm run test:unit` - fast unit tests only
- `npm run test:integration` - integration tests with containers
- `npm run test:all` - everything

Ensure build happens before integration tests by adding to integration config:
```typescript
// In integration project config
beforeAll: async () => {
  // Ensure dist is built
  const { execSync } = require('child_process');
  execSync('npm run build:rlm', { stdio: 'inherit' });
}
```

Or add to global-setup.ts.
  </action>
  <verify>
npm run test:unit runs only unit tests.
npm run test:integration runs integration tests (requires Docker).
package.json has all three test scripts.
  </verify>
  <done>Test scripts configured for unit-only, integration-only, and combined test runs.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run test:unit` runs unit tests without containers
2. `npm run test:integration` starts Qdrant container and runs integration tests
3. JSON-RPC compliance tests verify 2.0 specification
4. MCP tools are correctly registered and listed
5. Error responses have proper structure
</verification>

<success_criteria>
- Global setup starts/stops Qdrant container automatically
- JSON-RPC 2.0 compliance verified (version, id echo, result/error exclusivity)
- tools/list returns all three MCP tools with proper schema
- Error handling returns proper JSON-RPC error objects
- Stdout contains only JSON-RPC, logs go to stderr
- npm scripts allow running unit/integration/all tests
</success_criteria>

<output>
After completion, create `.planning/phases/07-test-coverage/07-03-SUMMARY.md`
</output>
