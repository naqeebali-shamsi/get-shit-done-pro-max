---
phase: 07-test-coverage
plan: 04
type: execute
wave: 3
depends_on: ["07-02", "07-03"]
files_modified:
  - tests/e2e/mcp-server.e2e.test.ts
autonomous: false

must_haves:
  truths:
    - "E2E test spawns actual MCP server and communicates via stdio"
    - "Full flow verified: index -> search -> verify results"
    - "TOON output is valid and contains expected fields"
    - "Overall test coverage reaches 85%"
  artifacts:
    - path: "tests/e2e/mcp-server.e2e.test.ts"
      provides: "End-to-end MCP server tests"
      contains: "describe.*MCP Server E2E"
  key_links:
    - from: "tests/e2e/mcp-server.e2e.test.ts"
      to: "dist/rlm/mcp/server.js"
      via: "child_process.spawn"
      pattern: "spawn.*server\\.js"
---

<objective>
Create end-to-end tests that spawn the MCP server and verify full workflows.

Purpose: Satisfy TST-04 (E2E test with spawned MCP server) and verify TST-01 (85% coverage) is achieved.
Output: E2E test file that tests the complete index->search->verify flow.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-test-coverage/07-RESEARCH.md
@.planning/phases/07-test-coverage/07-02-SUMMARY.md
@.planning/phases/07-test-coverage/07-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create E2E test for MCP server full workflow</name>
  <files>tests/e2e/mcp-server.e2e.test.ts</files>
  <action>
Create tests/e2e/ directory.

Create mcp-server.e2e.test.ts with full workflow tests:

```typescript
import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';
import { spawn, ChildProcess, execSync } from 'child_process';
import { join } from 'path';
import { decode } from '@toon-format/toon';
import { mkdtempSync, writeFileSync, rmSync } from 'fs';
import { tmpdir } from 'os';

describe('MCP Server E2E', () => {
  let server: ChildProcess;
  let requestId = 0;
  let tempDir: string;

  const sendRequest = (method: string, params: object = {}): Promise<any> => {
    return new Promise((resolve, reject) => {
      const id = ++requestId;
      const request = JSON.stringify({
        jsonrpc: '2.0',
        id,
        method,
        params
      }) + '\n';

      const timeout = setTimeout(() => {
        reject(new Error(`Request timeout for ${method}`));
      }, 30000); // 30s timeout for indexing

      const handler = (data: Buffer) => {
        const lines = data.toString().split('\n').filter(Boolean);
        for (const line of lines) {
          try {
            const response = JSON.parse(line);
            if (response.id === id) {
              clearTimeout(timeout);
              server.stdout?.off('data', handler);
              resolve(response);
            }
          } catch { /* ignore non-JSON */ }
        }
      };

      server.stdout?.on('data', handler);
      server.stdin?.write(request);
    });
  };

  beforeAll(async () => {
    // Build to ensure latest code
    execSync('npm run build:rlm', { stdio: 'inherit', cwd: join(__dirname, '../..') });

    // Create temp directory with test files
    tempDir = mkdtempSync(join(tmpdir(), 'rlm-e2e-'));

    // Write test fixture
    writeFileSync(join(tempDir, 'calculator.ts'), `
      export function add(a: number, b: number): number {
        return a + b;
      }

      export function subtract(a: number, b: number): number {
        return a - b;
      }
    `);

    // Start MCP server
    server = spawn('node', [join(__dirname, '../../dist/rlm/mcp/server.js')], {
      stdio: ['pipe', 'pipe', 'pipe'],
      env: {
        ...process.env,
        QDRANT_URL: process.env.QDRANT_URL || 'http://localhost:6333',
        RLM_COLLECTION: `rlm_e2e_${Date.now()}` // Unique collection per run
      }
    });

    // Wait for server startup
    await new Promise(resolve => setTimeout(resolve, 2000));
  }, 120000); // 2 min timeout for setup

  afterAll(async () => {
    server.kill('SIGTERM');
    // Cleanup temp directory
    rmSync(tempDir, { recursive: true, force: true });
  });

  describe('get_status tool', () => {
    it('reports system status', async () => {
      const response = await sendRequest('tools/call', {
        name: 'get_status',
        arguments: {}
      });

      expect(response.result).toHaveProperty('content');
      expect(response.result.content[0].text).toContain('RLM System Status');
    });
  });

  describe('index_code tool', () => {
    it('indexes a directory and reports results', async () => {
      const response = await sendRequest('tools/call', {
        name: 'index_code',
        arguments: { path: tempDir }
      });

      expect(response.result).toHaveProperty('content');
      const text = response.result.content[0].text;
      expect(text).toContain('Indexing complete');
      expect(text).toContain('Files indexed');
    }, 60000); // 60s timeout for indexing
  });

  describe('search_code tool', () => {
    it('searches indexed code and returns TOON results', async () => {
      // First ensure indexed (may already be from previous test)
      await sendRequest('tools/call', {
        name: 'index_code',
        arguments: { path: tempDir }
      });

      // Now search
      const response = await sendRequest('tools/call', {
        name: 'search_code',
        arguments: { query: 'add numbers', limit: 5 }
      });

      expect(response.result).toHaveProperty('content');
      const text = response.result.content[0].text;

      // Verify TOON format
      const decoded = decode(text);
      expect(decoded).toHaveProperty('results');
      expect(Array.isArray(decoded.results)).toBe(true);
    }, 30000);

    it('TOON results have required fields', async () => {
      const response = await sendRequest('tools/call', {
        name: 'search_code',
        arguments: { query: 'function', limit: 3 }
      });

      const { results } = decode(response.result.content[0].text);

      for (const result of results) {
        expect(result).toHaveProperty('file');
        expect(result).toHaveProperty('lines');
        expect(result).toHaveProperty('relevance');
        expect(result).toHaveProperty('code');
        expect(typeof result.relevance).toBe('number');
      }
    }, 30000);
  });

  describe('full workflow', () => {
    it('index -> search -> verify results contain expected code', async () => {
      // Index
      const indexResponse = await sendRequest('tools/call', {
        name: 'index_code',
        arguments: { path: tempDir }
      });
      expect(indexResponse.result.content[0].text).toContain('Indexing complete');

      // Search for specific function
      const searchResponse = await sendRequest('tools/call', {
        name: 'search_code',
        arguments: { query: 'subtract function', limit: 5 }
      });

      const { results } = decode(searchResponse.result.content[0].text);
      expect(results.length).toBeGreaterThan(0);

      // Verify result contains expected code
      const hasSubtract = results.some((r: any) =>
        r.code.includes('subtract') || r.code.includes('a - b')
      );
      expect(hasSubtract).toBe(true);
    }, 60000);
  });
});
```

Key E2E test scenarios:
1. get_status returns status information
2. index_code indexes a temp directory
3. search_code returns TOON-formatted results
4. TOON output has all required fields
5. Full workflow: index -> search -> verify content
  </action>
  <verify>
npm run test:integration -- tests/e2e/mcp-server.e2e.test.ts passes.
Tests spawn actual server and communicate via stdio.
  </verify>
  <done>E2E tests created for full MCP server workflow including index->search->verify.</done>
</task>

<task type="auto">
  <name>Task 2: Verify 85% test coverage achieved</name>
  <files>package.json</files>
  <action>
Run full test suite with coverage:
```bash
npm run test:coverage
```

Check coverage report for src/rlm/ modules:
- Overall should be >= 85%
- Critical tier (mcp/, cli/) should be >= 90%

If coverage is below threshold:
1. Identify uncovered branches in coverage/html report
2. Add targeted tests for uncovered error paths
3. Focus on catch blocks, edge cases, early returns

Common coverage gaps to check:
- Error handling in catch blocks
- Edge cases (empty arrays, null inputs)
- Conditional branches (if/else)
- Default parameter paths

Add any missing tests to appropriate test files.

Update vitest.config.ts coverage thresholds to enforce:
```typescript
thresholds: {
  lines: 85,
  functions: 85,
  branches: 80,  // Slightly lower for branches
  statements: 85,
}
```
  </action>
  <verify>
npm run test:coverage shows >= 85% overall coverage.
Coverage report HTML generated in coverage/ directory.
CI will fail if coverage drops below threshold.
  </verify>
  <done>Test coverage verified at 85%+ with thresholds enforced in CI.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete test suite for RLM MCP server:
- Unit tests for all MCP tools (search, index, status)
- Unit tests for TOON formatter and logger
- Integration tests for JSON-RPC protocol compliance
- E2E tests for full index->search->verify workflow
- Coverage configuration with tiered thresholds
  </what-built>
  <how-to-verify>
1. Run unit tests: `npm run test:unit`
   - All tests should pass
   - No external dependencies required

2. Run integration tests (requires Docker): `npm run test:integration`
   - Qdrant container should start automatically
   - JSON-RPC compliance tests should pass
   - E2E workflow tests should pass

3. Check coverage: `npm run test:coverage`
   - Open coverage/index.html in browser
   - Verify src/rlm/ coverage >= 85%
   - Verify src/rlm/mcp/ coverage >= 90%

4. Verify E2E workflow manually:
   - Start services: `docker run -p 6333:6333 qdrant/qdrant`
   - Start server: `node dist/rlm/mcp/server.js`
   - Observe startup logs on stderr
   - Send test request to stdin and verify JSON response on stdout
  </how-to-verify>
  <resume-signal>Type "approved" when tests pass and coverage meets targets, or describe any issues.</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run test:unit` passes all unit tests
2. `npm run test:integration` passes all integration/E2E tests
3. `npm run test:coverage` shows >= 85% coverage
4. Coverage HTML report available at coverage/index.html
5. Human verification confirms full workflow works
</verification>

<success_criteria>
- TST-01: 85% test coverage on src/rlm/ modules verified
- TST-02: Unit tests for MCP tool handlers complete
- TST-03: Integration tests for JSON-RPC compliance passing
- TST-04: E2E test spawns MCP server, executes all tools, verifies results
- Coverage thresholds enforced (CI will fail if dropped)
- TOON output verified via decode() in tests
</success_criteria>

<output>
After completion, create `.planning/phases/07-test-coverage/07-04-SUMMARY.md`
</output>
