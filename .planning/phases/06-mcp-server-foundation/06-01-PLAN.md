---
phase: 06-mcp-server-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/rlm/mcp/server.ts
  - src/rlm/mcp/tools/search.ts
  - src/rlm/mcp/tools/index-code.ts
  - src/rlm/mcp/tools/status.ts
  - src/rlm/mcp/logger.ts
  - src/rlm/mcp/index.ts
autonomous: true

must_haves:
  truths:
    - "MCP server starts via rlm-mcp command"
    - "Server communicates over stdio using JSON-RPC"
    - "Claude Desktop can call search_code tool"
    - "Claude Desktop can call index_code tool"
    - "Claude Desktop can call get_status tool"
    - "Errors logged to stderr only, stdout reserved for JSON-RPC"
  artifacts:
    - path: "src/rlm/mcp/server.ts"
      provides: "MCP server entry point with stdio transport"
      exports: ["main"]
    - path: "src/rlm/mcp/tools/search.ts"
      provides: "search_code tool handler"
      exports: ["registerSearchTool"]
    - path: "src/rlm/mcp/tools/index-code.ts"
      provides: "index_code tool handler"
      exports: ["registerIndexTool"]
    - path: "src/rlm/mcp/tools/status.ts"
      provides: "get_status tool handler"
      exports: ["registerStatusTool"]
    - path: "src/rlm/mcp/logger.ts"
      provides: "stderr-only logging utility"
      exports: ["log", "logError"]
  key_links:
    - from: "src/rlm/mcp/server.ts"
      to: "src/rlm/mcp/tools/*.ts"
      via: "tool registration calls"
      pattern: "register.*Tool\\(server\\)"
    - from: "src/rlm/mcp/tools/search.ts"
      to: "src/rlm/retrieval/hybrid-search.ts"
      via: "hybridSearch import"
      pattern: "import.*hybridSearch"
    - from: "src/rlm/mcp/tools/index-code.ts"
      to: "src/rlm/indexing/indexer.ts"
      via: "indexDirectory import"
      pattern: "import.*indexDirectory"
    - from: "src/rlm/mcp/tools/status.ts"
      to: "src/rlm/storage/qdrant-client.ts"
      via: "getCollectionInfo import"
      pattern: "import.*getCollectionInfo"
---

<objective>
Create the MCP server foundation that exposes RLM capabilities via the Model Context Protocol for Claude Desktop integration.

Purpose: Enable Claude Desktop to search, index, and query the RLM vector database through the standard MCP tool interface.

Output:
- Working MCP server with stdio transport
- Three tools: search_code, index_code, get_status
- Proper error handling with actionable guidance
- npm bin entry for rlm-mcp command
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-mcp-server-foundation/06-RESEARCH.md

# Existing APIs to wrap
@src/rlm/retrieval/hybrid-search.ts
@src/rlm/indexing/indexer.ts
@src/rlm/storage/qdrant-client.ts
@src/rlm/cli/rlm-cli.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and add bin entry</name>
  <files>package.json</files>
  <action>
Install MCP SDK and TOON dependencies:
```bash
npm install @modelcontextprotocol/sdk @toon-format/toon
```

Update package.json bin entry to add rlm-mcp alongside existing rlm entry:
```json
"bin": {
  "get-shit-done-cc": "bin/install.js",
  "rlm": "dist/rlm/cli/rlm-cli.js",
  "rlm-mcp": "dist/rlm/mcp/server.js"
}
```

This satisfies INT-02 (npm bin entry) and INT-04 (@toon-format/toon dependency).
  </action>
  <verify>
Run `npm ls @modelcontextprotocol/sdk @toon-format/toon` - both packages listed.
Check package.json contains rlm-mcp bin entry.
  </verify>
  <done>
Dependencies installed and bin entry added. `npm ls` shows both packages, package.json has rlm-mcp entry.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create MCP server with stdio transport and stderr logging</name>
  <files>src/rlm/mcp/server.ts, src/rlm/mcp/logger.ts, src/rlm/mcp/index.ts</files>
  <action>
Create src/rlm/mcp/logger.ts - stderr-only logging utility:
```typescript
/**
 * Stderr-only logging for MCP server.
 * CRITICAL: stdout is reserved for JSON-RPC protocol.
 * Any non-JSON-RPC output to stdout will break the protocol.
 */

export type LogLevel = 'info' | 'warn' | 'error' | 'debug';

interface LogEntry {
  timestamp: string;
  level: LogLevel;
  message: string;
  data?: Record<string, unknown>;
}

export function log(level: LogLevel, message: string, data?: Record<string, unknown>): void {
  const entry: LogEntry = {
    timestamp: new Date().toISOString(),
    level,
    message,
    ...(data && { data }),
  };
  process.stderr.write(JSON.stringify(entry) + '\n');
}

export function logInfo(message: string, data?: Record<string, unknown>): void {
  log('info', message, data);
}

export function logError(message: string, data?: Record<string, unknown>): void {
  log('error', message, data);
}

export function logWarn(message: string, data?: Record<string, unknown>): void {
  log('warn', message, data);
}
```

Create src/rlm/mcp/server.ts - MCP server entry point:
```typescript
#!/usr/bin/env node
/**
 * RLM MCP Server - Model Context Protocol server for Claude Desktop
 *
 * Exposes RLM capabilities via MCP tools:
 * - search_code: Search indexed codebase
 * - index_code: Index a directory
 * - get_status: Check system status
 *
 * Phase 6: MCP Server Foundation
 */

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { logInfo, logError } from './logger.js';
import { registerSearchTool } from './tools/search.js';
import { registerIndexTool } from './tools/index-code.js';
import { registerStatusTool } from './tools/status.js';

const VERSION = '1.0.0';

async function main(): Promise<void> {
  logInfo('Starting RLM MCP server', { version: VERSION });

  const server = new McpServer({
    name: 'rlm-mcp',
    version: VERSION,
  });

  // Register all tools
  registerSearchTool(server);
  registerIndexTool(server);
  registerStatusTool(server);

  // Connect to stdio transport
  const transport = new StdioServerTransport();
  await server.connect(transport);

  logInfo('Connected to stdio transport');
}

main().catch((err) => {
  logError('Fatal error', { message: err.message, stack: err.stack });
  process.exit(1);
});

export { main };
```

Create src/rlm/mcp/index.ts - re-exports for programmatic use:
```typescript
/**
 * MCP Server Module
 *
 * Exposes RLM capabilities via Model Context Protocol.
 */

export { main } from './server.js';
export { log, logInfo, logError, logWarn } from './logger.js';
```

This satisfies MCP-01 (stdio transport) and MCP-07 (stderr-only logging).
  </action>
  <verify>
Run `npx tsc -p tsconfig.json` - compiles without errors.
Check src/rlm/mcp/server.ts exists with McpServer and StdioServerTransport imports.
Check src/rlm/mcp/logger.ts uses process.stderr.write, not console.log.
  </verify>
  <done>
MCP server entry point created with stdio transport. Logger uses stderr only. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement all three MCP tools with zod schemas</name>
  <files>src/rlm/mcp/tools/search.ts, src/rlm/mcp/tools/index-code.ts, src/rlm/mcp/tools/status.ts</files>
  <action>
Create src/rlm/mcp/tools/search.ts - search_code tool:
```typescript
/**
 * search_code MCP Tool
 *
 * Wraps hybridSearch to search indexed codebase.
 */

import type { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";
import { createQdrantClient } from '../../storage/index.js';
import { hybridSearch } from '../../retrieval/hybrid-search.js';
import { logInfo, logError } from '../logger.js';

const COLLECTION_NAME = process.env.RLM_COLLECTION || 'rlm_chunks';

const searchSchema = {
  query: z.string()
    .min(1)
    .max(500)
    .describe("Natural language query describing what code to find. Example: 'authentication middleware' or 'how does user validation work'"),
  limit: z.number()
    .int()
    .min(1)
    .max(20)
    .default(5)
    .describe("Maximum number of results to return (default: 5, max: 20)")
};

export function registerSearchTool(server: McpServer): void {
  server.tool(
    "search_code",
    "Search the indexed codebase for relevant code, functions, or documentation.\n\nUse this when:\n- User asks about specific code functionality\n- Need to find how a feature is implemented\n- Looking for examples of a pattern in the codebase\n- Want to understand code structure\n\nReturns: Array of code chunks with file paths, line numbers, and relevance scores.",
    searchSchema,
    async ({ query, limit }) => {
      logInfo('search_code called', { query, limit });

      try {
        const qdrantUrl = process.env.QDRANT_URL || 'http://localhost:6333';
        const client = await createQdrantClient({ url: qdrantUrl });

        const results = await hybridSearch(client, COLLECTION_NAME, query, { limit });

        if (results.length === 0) {
          return {
            content: [{
              type: "text" as const,
              text: `No matches found for "${query}".\n\nSuggestions:\n- Try broader search terms\n- Verify the codebase is indexed (use get_status tool)\n- Check if the code you're looking for exists`
            }]
          };
        }

        // Format results as structured text (TOON formatting added in Plan 02)
        const formatted = results.map((r, i) => {
          const { path, start_line, end_line } = r.chunk.metadata;
          const score = Math.round(r.score * 100);
          return `## Result ${i + 1} (${score}% relevance)\nFile: ${path}\nLines: ${start_line}-${end_line}\n\n\`\`\`\n${r.chunk.text}\n\`\`\``;
        }).join('\n\n---\n\n');

        logInfo('search_code success', { query, results: results.length });

        return {
          content: [{ type: "text" as const, text: formatted }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        logError('search_code failed', { query, error: message });

        return {
          content: [{
            type: "text" as const,
            text: `Search failed: ${message}\n\nTroubleshooting:\n1. Ensure Qdrant is running (docker run -p 6333:6333 qdrant/qdrant)\n2. Ensure Ollama is running (ollama serve)\n3. Verify codebase is indexed (rlm index .)`
          }],
          isError: true
        };
      }
    }
  );
}
```

Create src/rlm/mcp/tools/index-code.ts - index_code tool:
```typescript
/**
 * index_code MCP Tool
 *
 * Wraps indexDirectory to index a codebase directory.
 */

import type { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";
import { createQdrantClient } from '../../storage/index.js';
import { indexDirectory } from '../../indexing/index.js';
import { logInfo, logError } from '../logger.js';

const COLLECTION_NAME = process.env.RLM_COLLECTION || 'rlm_chunks';

const indexSchema = {
  path: z.string()
    .min(1)
    .describe("Absolute or relative path to directory to index. Example: '/home/user/project' or './src'")
};

export function registerIndexTool(server: McpServer): void {
  server.tool(
    "index_code",
    "Index a directory to enable code search. Creates embeddings for all supported files (.ts, .js, .tsx, .jsx, .md).\n\nUse this when:\n- User wants to index a new codebase or directory\n- Need to refresh the index after code changes\n- First-time setup before searching\n\nNote: May take 30-60 seconds for large codebases. Returns summary of indexed files.",
    indexSchema,
    async ({ path }) => {
      logInfo('index_code called', { path });

      try {
        const qdrantUrl = process.env.QDRANT_URL || 'http://localhost:6333';
        const client = await createQdrantClient({ url: qdrantUrl });

        const startTime = Date.now();
        const result = await indexDirectory(client, COLLECTION_NAME, path);
        const elapsed = Date.now() - startTime;

        const summary = [
          `Indexing complete in ${elapsed}ms`,
          `- Files indexed: ${result.indexed}`,
          `- Files skipped (unchanged): ${result.skipped}`,
        ];

        if (result.errors.length > 0) {
          summary.push(`- Errors: ${result.errors.length}`);
          summary.push('');
          summary.push('First 3 errors:');
          result.errors.slice(0, 3).forEach(err => {
            summary.push(`  - ${err}`);
          });
        }

        logInfo('index_code success', {
          path,
          indexed: result.indexed,
          skipped: result.skipped,
          errors: result.errors.length,
          elapsed
        });

        return {
          content: [{ type: "text" as const, text: summary.join('\n') }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        logError('index_code failed', { path, error: message });

        return {
          content: [{
            type: "text" as const,
            text: `Indexing failed: ${message}\n\nTroubleshooting:\n1. Ensure Qdrant is running (docker run -p 6333:6333 qdrant/qdrant)\n2. Ensure Ollama is running with nomic-embed-text (ollama pull nomic-embed-text)\n3. Verify the path exists and contains supported files`
          }],
          isError: true
        };
      }
    }
  );
}
```

Create src/rlm/mcp/tools/status.ts - get_status tool:
```typescript
/**
 * get_status MCP Tool
 *
 * Wraps getCollectionInfo to check system status.
 */

import type { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";
import { createQdrantClient, getCollectionInfo } from '../../storage/index.js';
import { logInfo, logError } from '../logger.js';

const COLLECTION_NAME = process.env.RLM_COLLECTION || 'rlm_chunks';

// Empty schema - no parameters needed
const statusSchema = {};

export function registerStatusTool(server: McpServer): void {
  server.tool(
    "get_status",
    "Check the status of the RLM indexing system.\n\nUse this when:\n- Need to verify services are running\n- Want to see how many chunks are indexed\n- Troubleshooting search or index failures\n\nReturns: Connection status for Qdrant, collection name, and chunk count.",
    statusSchema,
    async () => {
      logInfo('get_status called');

      const qdrantUrl = process.env.QDRANT_URL || 'http://localhost:6333';
      const ollamaHost = process.env.OLLAMA_HOST || 'http://localhost:11434';

      let qdrantStatus = 'disconnected';
      let collectionStatus = 'not found';
      let chunksIndexed = 0;

      try {
        const client = await createQdrantClient({ url: qdrantUrl });

        // Check Qdrant connection
        try {
          await client.getCollections();
          qdrantStatus = 'connected';
        } catch {
          qdrantStatus = 'disconnected';
        }

        // Check collection
        if (qdrantStatus === 'connected') {
          const info = await getCollectionInfo(client, COLLECTION_NAME);
          if (info) {
            collectionStatus = 'exists';
            chunksIndexed = info.points_count;
          }
        }

        const status = [
          '## RLM System Status',
          '',
          `**Qdrant:** ${qdrantStatus} (${qdrantUrl})`,
          `**Ollama:** configured (${ollamaHost})`,
          `**Collection:** ${collectionStatus} (${COLLECTION_NAME})`,
          `**Chunks indexed:** ${chunksIndexed}`,
        ];

        if (qdrantStatus === 'disconnected') {
          status.push('');
          status.push('**Action needed:** Start Qdrant with `docker run -p 6333:6333 qdrant/qdrant`');
        } else if (chunksIndexed === 0) {
          status.push('');
          status.push('**Action needed:** Index your codebase with the index_code tool');
        }

        logInfo('get_status success', { qdrantStatus, collectionStatus, chunksIndexed });

        return {
          content: [{ type: "text" as const, text: status.join('\n') }]
        };
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        logError('get_status failed', { error: message });

        return {
          content: [{
            type: "text" as const,
            text: `Status check failed: ${message}\n\nEnsure Qdrant is running and accessible at ${qdrantUrl}`
          }],
          isError: true
        };
      }
    }
  );
}
```

This satisfies:
- MCP-02: search_code tool wrapping hybridSearch
- MCP-03: index_code tool wrapping indexDirectory
- MCP-04: get_status tool wrapping getCollectionInfo
- MCP-05: JSON schema definitions via zod
- MCP-06: Structured error responses with actionable guidance
- INT-03: Environment variable support (QDRANT_URL, OLLAMA_HOST, RLM_COLLECTION)
  </action>
  <verify>
Run `npx tsc -p tsconfig.json` - compiles without errors.
Run `npm run build:rlm` - builds successfully.
Test manually: `echo '{"jsonrpc":"2.0","method":"tools/list","id":1}' | node dist/rlm/mcp/server.js` should return tool list (may fail if services not running, but should not crash).
  </verify>
  <done>
All three tools implemented with zod schemas, proper error handling, and env var support. TypeScript compiles without errors.
  </done>
</task>

</tasks>

<verification>
1. Dependencies installed: `npm ls @modelcontextprotocol/sdk @toon-format/toon` shows both packages
2. Build succeeds: `npm run build:rlm` completes without errors
3. Server starts: `node dist/rlm/mcp/server.js` starts without crashing (stderr shows "Starting RLM MCP server")
4. Tools registered: Server responds to tools/list JSON-RPC call with 3 tools
5. Stdout clean: No non-JSON-RPC output on stdout during startup
</verification>

<success_criteria>
- [ ] @modelcontextprotocol/sdk and @toon-format/toon installed
- [ ] package.json has rlm-mcp bin entry pointing to dist/rlm/mcp/server.js
- [ ] src/rlm/mcp/server.ts exists with McpServer and StdioServerTransport
- [ ] src/rlm/mcp/logger.ts exists using process.stderr.write only
- [ ] src/rlm/mcp/tools/search.ts exports registerSearchTool
- [ ] src/rlm/mcp/tools/index-code.ts exports registerIndexTool
- [ ] src/rlm/mcp/tools/status.ts exports registerStatusTool
- [ ] TypeScript compiles without errors
- [ ] Server starts and logs to stderr
</success_criteria>

<output>
After completion, create `.planning/phases/06-mcp-server-foundation/06-01-SUMMARY.md`
</output>
