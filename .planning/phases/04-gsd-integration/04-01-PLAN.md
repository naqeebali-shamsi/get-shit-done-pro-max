---
phase: 04-gsd-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/rlm/integration/quick-retrieve.ts, src/rlm/integration/context-formatter.ts, src/rlm/integration/index.ts, src/rlm/index.ts]
autonomous: true
---

<objective>
Create fast retrieval path and context formatting utilities for GSD integration.

Purpose: Enable quick semantic search (without full RLM pipeline) suitable for hooks and CLI tools. The full RLMDispatcher pipeline is too slow for hooks (~2-5s); this provides a fast path (~100-500ms) that skips LLM calls and verification.

Output: Integration module with quickRetrieve() and formatChunksAsContext() exported from src/rlm/index.ts
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-gsd-integration/04-RESEARCH.md

Relevant source files:
@src/rlm/retrieval/hybrid-search.ts
@src/rlm/storage/qdrant-client.ts
@src/rlm/types.ts
@src/rlm/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create quickRetrieve function</name>
  <files>src/rlm/integration/quick-retrieve.ts</files>
  <action>
Create quick-retrieve.ts with a fast retrieval function optimized for hooks:

1. Export interface QuickRetrieveOptions:
   - limit: number (default 5)
   - timeout: number (default 500ms)
   - scoreThreshold: number (default 0.3)

2. Export async function quickRetrieve(query: string, options?: QuickRetrieveOptions):
   - Use singleton Qdrant client (createQdrantClient from storage)
   - Call hybridSearch with limit from options
   - Wrap in Promise.race with timeout
   - On timeout, return empty array (graceful degradation)
   - On error, log to stderr and return empty array (never throw)
   - Return Chunk[] (just chunks, not full SearchResult)

3. Create internal getQdrantClient() that returns singleton:
   - Check QDRANT_URL env var (default http://localhost:6333)
   - Lazy initialization on first call
   - Handle connection errors gracefully

The function must NEVER throw - GSD hooks depend on graceful degradation.
  </action>
  <verify>npm run build:rlm compiles without errors</verify>
  <done>quickRetrieve function exists, handles timeouts and errors gracefully, returns Chunk[]</done>
</task>

<task type="auto">
  <name>Task 2: Create context formatting utilities</name>
  <files>src/rlm/integration/context-formatter.ts</files>
  <action>
Create context-formatter.ts with utilities to format chunks as readable context:

1. Export interface ContextFormatOptions:
   - maxChunks: number (default 5)
   - maxLinesPerChunk: number (default 50)
   - includeConfidence: boolean (default true)
   - format: 'markdown' | 'plain' (default 'markdown')

2. Export function formatChunksAsContext(chunks: Chunk[], scores?: number[], options?: ContextFormatOptions): string
   - Take top N chunks based on maxChunks
   - For each chunk, format as:
     ```
     ### {path}:{start_line}-{end_line}
     ```{language}
     {text (truncated to maxLinesPerChunk)}
     ```
     [Relevance: {score}%] (if includeConfidence)
     ```
   - If chunk.text exceeds maxLinesPerChunk, truncate with "... (truncated)"
   - Return empty string if no chunks

3. Export function formatSingleChunk(chunk: Chunk, score?: number): string
   - Format individual chunk with metadata header
   - Used for streaming/incremental output

4. Helper function truncateLines(text: string, maxLines: number): string
   - Split by newline, take first maxLines
   - Append "... (truncated, {remaining} more lines)" if truncated

Keep formatting simple and readable. Markdown format should work in Claude's context.
  </action>
  <verify>npm run build:rlm compiles without errors</verify>
  <done>formatChunksAsContext and formatSingleChunk functions exist, produce readable markdown output</done>
</task>

<task type="auto">
  <name>Task 3: Create integration module and update exports</name>
  <files>src/rlm/integration/index.ts, src/rlm/index.ts</files>
  <action>
1. Create src/rlm/integration/index.ts:
   - Re-export everything from quick-retrieve.ts
   - Re-export everything from context-formatter.ts

2. Update src/rlm/index.ts:
   - Add section comment: "// Phase 4: GSD Integration (VER-04)"
   - Export from './integration/index.js':
     - quickRetrieve, QuickRetrieveOptions
     - formatChunksAsContext, formatSingleChunk, ContextFormatOptions

The integration module should be usable like:
```typescript
import { quickRetrieve, formatChunksAsContext } from './rlm/index.js';

const chunks = await quickRetrieve("how does auth work", { timeout: 500 });
const context = formatChunksAsContext(chunks);
```
  </action>
  <verify>npm run build:rlm compiles without errors; imports resolve correctly</verify>
  <done>Integration module exports available from main src/rlm/index.ts</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build:rlm` succeeds without errors
- [ ] quickRetrieve handles timeout gracefully (returns [] on timeout)
- [ ] quickRetrieve handles connection errors gracefully (returns [] on error)
- [ ] formatChunksAsContext produces readable markdown
- [ ] All new types and functions exported from src/rlm/index.ts
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors
- quickRetrieve never throws (graceful degradation)
- formatChunksAsContext produces clean, readable output
  </success_criteria>

<output>
After completion, create `.planning/phases/04-gsd-integration/04-01-SUMMARY.md`
</output>
