---
phase: 03-verification-loop
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified: [src/rlm/verification/checks/typecheck.ts, src/rlm/verification/checks/test-runner.ts, src/rlm/verification/checks/impact-scan.ts, src/rlm/verification/checks/index.ts]
autonomous: true
---

<objective>
Implement the three verification checks: typecheck, test execution, and impact scan (VER-01).

Purpose: Core verification capabilities using ts-morph and Vitest programmatic APIs.
Output: Three check modules that return structured CheckResult objects.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-verification-loop/03-RESEARCH.md
@.planning/phases/03-verification-loop/03-01-SUMMARY.md

# Types from Plan 03-01
@src/rlm/verification/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install ts-morph and implement typecheck</name>
  <files>src/rlm/verification/checks/typecheck.ts</files>
  <action>
First, install ts-morph:
```bash
npm install ts-morph
```

Create src/rlm/verification/checks/ directory and typecheck.ts:

```typescript
import { Project, DiagnosticCategory } from 'ts-morph';
import type { CheckResult } from '../types.js';
```

**Module-level state:** Initialize Project ONCE (performance per research):
```typescript
let project: Project | null = null;

function getProject(): Project {
  if (!project) {
    project = new Project({
      tsConfigFilePath: 'tsconfig.json',
      skipAddingFilesFromTsConfig: true, // We add files explicitly
    });
  }
  return project;
}
```

**Function: typecheckFiles(filePaths: string[]): Promise<CheckResult>**
1. Get or create Project instance
2. Add source files: `project.addSourceFilesAtPaths(filePaths)`
3. Get semantic diagnostics for each file: `sourceFile.getPreEmitDiagnostics()`
4. Map diagnostics to errors array:
   - message: `diagnostic.getMessageText().toString()`
   - line: `diagnostic.getLineNumber() || 0`
   - file: `sourceFile.getFilePath()`
   - Severity from DiagnosticCategory (Error vs Warning)
5. Return CheckResult with passed = (errors with severity 'error' === 0)

**Function: resetProject(): void**
- Set project = null (for testing or after major changes)

IMPORTANT: Don't run full project type check - only check specified files. This avoids the performance pitfall mentioned in research.
  </action>
  <verify>typecheckFiles(['src/rlm/types.ts']) returns CheckResult with passed=true</verify>
  <done>TypeScript type checking via ts-morph programmatic API</done>
</task>

<task type="auto">
  <name>Task 2: Implement test runner using Vitest Node API</name>
  <files>src/rlm/verification/checks/test-runner.ts</files>
  <action>
Create test-runner.ts using Vitest's programmatic Node API:

```typescript
import { startVitest } from 'vitest/node';
import type { CheckResult } from '../types.js';
```

**Function: runTests(testPatterns: string[], timeout?: number): Promise<CheckResult>**
1. Start Vitest programmatically:
   ```typescript
   const vitest = await startVitest('test', testPatterns, {
     watch: false,
     reporters: ['default'],
   });
   ```
2. Get test modules: `vitest.state.getTestModules()`
3. Map to results:
   ```typescript
   const results = modules.map(m => ({
     file: m.moduleId,
     ok: m.ok(),
   }));
   ```
4. Close Vitest: `await vitest.close()`
5. Build CheckResult:
   - passed: all results.ok === true
   - errors: failed tests mapped to { message, file }
   - duration: track with Date.now()

**Function: runTestsForFiles(changedFiles: string[]): Promise<CheckResult>**
- Convert changed files to test patterns: `file.ts` â†’ `file.test.ts` or `file.spec.ts`
- Check if test file exists before adding to patterns
- Call runTests with discovered patterns

Handle timeout:
- Use AbortController or setTimeout to enforce timeout
- Return CheckResult with error if timeout exceeded

NOTE: If Vitest workspace issues occur (per research open question), fall back to shell execution as backup.
  </action>
  <verify>runTests(['src/**/*.test.ts']) returns CheckResult (or empty if no tests exist)</verify>
  <done>Programmatic test execution via Vitest Node API</done>
</task>

<task type="auto">
  <name>Task 3: Implement impact scan using ts-morph findReferences</name>
  <files>src/rlm/verification/checks/impact-scan.ts</files>
  <action>
Create impact-scan.ts using ts-morph reference analysis:

```typescript
import { Project } from 'ts-morph';
import type { CheckResult } from '../types.js';
```

Reuse the project singleton from typecheck.ts:
```typescript
import { getProject } from './typecheck.js';
```

**Interface: ImpactResult extends CheckResult**
- impactedFiles: string[] (files that reference changed symbols)
- affectedTests: string[] (test files that may need to run)

**Function: scanImpact(changedFile: string, symbolName?: string): Promise<ImpactResult>**
1. Get Project instance
2. Get source file: `project.getSourceFile(changedFile)`
3. If symbolName provided, find the symbol:
   - Try getFunction(symbolName), getClass(symbolName), getVariableDeclaration(symbolName)
4. If symbol found, get references: `symbol.findReferencesAsNodes()`
5. Extract unique file paths from referencing nodes
6. Identify which are test files (*.test.ts, *.spec.ts)
7. Return ImpactResult with:
   - passed: true (impact scan doesn't fail, just informs)
   - impactedFiles: unique referencing file paths
   - affectedTests: test files from impactedFiles
   - errors: [] (or warnings if symbol not found)

**Function: getAffectedTestsForFiles(changedFiles: string[]): Promise<string[]>**
- Run scanImpact for each changed file
- Aggregate and dedupe affectedTests
- Return sorted list of test files to run

This enables the "run relevant tests only" optimization from research.
  </action>
  <verify>scanImpact('src/rlm/types.ts', 'Chunk') returns impacted files that import Chunk</verify>
  <done>Impact analysis via ts-morph findReferencesAsNodes</done>
</task>

<task type="auto">
  <name>Task 4: Create checks module index and export from verification</name>
  <files>src/rlm/verification/checks/index.ts</files>
  <action>
Create index.ts exporting all checks:

```typescript
/**
 * Verification Checks
 *
 * Three check types for VER-01:
 * - typecheck: TypeScript semantic analysis
 * - test-runner: Vitest programmatic execution
 * - impact-scan: Reference analysis for affected files
 */

export { typecheckFiles, resetProject, getProject } from './typecheck.js';
export { runTests, runTestsForFiles } from './test-runner.js';
export { scanImpact, getAffectedTestsForFiles, type ImpactResult } from './impact-scan.js';
```

Then update src/rlm/verification/index.ts to include:
```typescript
export * from './checks/index.js';
```
  </action>
  <verify>Can import: `import { typecheckFiles, runTests, scanImpact } from './verification/index.js'`</verify>
  <done>All checks exported from verification module</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] ts-morph package installed
- [ ] `npm run build:rlm` compiles all check modules
- [ ] typecheckFiles returns structured CheckResult with diagnostics
- [ ] runTests executes Vitest programmatically
- [ ] scanImpact identifies files that reference a symbol
- [ ] All checks return CheckResult interface
</verification>

<success_criteria>
- VER-01 satisfied: Verifier module with typecheck, test, impact scan
- Programmatic APIs used (not shell parsing)
- Project singleton for ts-morph performance
- Impact scan enables targeted test execution
</success_criteria>

<output>
After completion, create `.planning/phases/03-verification-loop/03-02-SUMMARY.md`
</output>
