---
phase: 03-verification-loop
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified: [src/rlm/verification/verifier.ts, src/rlm/verification/claims/coverage.ts, src/rlm/engine/dispatcher.ts, src/rlm/verification/index.ts, src/rlm/index.ts]
autonomous: true
---

<objective>
Create main Verifier class and integrate with RLMDispatcher for FIRE-style recursive refinement (VER-02, VER-03).

Purpose: Orchestrate all checks and integrate verification into the RLM pipeline with confidence-based recursion.
Output: Complete verification system integrated with dispatcher for autonomous refinement.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-verification-loop/03-RESEARCH.md
@.planning/phases/03-verification-loop/03-02-SUMMARY.md

# Existing dispatcher to integrate with
@src/rlm/engine/dispatcher.ts

# Verification types and checks from previous plans
@src/rlm/verification/types.ts
@src/rlm/verification/checks/index.ts
@src/rlm/verification/claims/extractor.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement evidence coverage checker</name>
  <files>src/rlm/verification/claims/coverage.ts</files>
  <action>
Create coverage.ts implementing VER-02 (evidence coverage checking):

```typescript
import type { AtomicClaim } from '../types.js';
import type { Evidence } from '../../engine/types.js';
```

**Interface: CoverageResult**
- totalClaims: number
- coveredClaims: number
- uncoveredClaims: AtomicClaim[]
- coverageRatio: number (0-1)
- gaps: Array<{ claim: AtomicClaim; reason: string }>

**Function: checkEvidenceCoverage(claims: AtomicClaim[], evidence: Evidence[]): CoverageResult**
1. For each verifiable claim, check if there's matching evidence:
   - Evidence.claim matches claim.text (fuzzy match - contains or similar)
   - Evidence.sourceChunks.length > 0 (has supporting chunks)
2. Track uncovered claims (verifiable but no evidence)
3. Calculate coverage ratio
4. Identify gaps with reasons:
   - "No evidence found"
   - "Evidence has no source chunks"
   - "Low confidence evidence" (if Evidence.confidence < 0.3)

**Function: generateRefinementQuery(gaps: CoverageResult['gaps'], originalQuery: string): string**
1. Analyze gap patterns:
   - If gaps involve specific files → "Need more context from {files}"
   - If gaps involve specific concepts → "Clarify: {concept}"
2. Construct refinement query that addresses gaps
3. Keep refinement focused (not repeating original query entirely)

This implements the FIRE pattern's "suggest refinement for recursion" capability.
  </action>
  <verify>checkEvidenceCoverage with 3 claims and 2 evidence entries returns coverageRatio ~0.67</verify>
  <done>Evidence coverage checking with gap analysis (VER-02)</done>
</task>

<task type="auto">
  <name>Task 2: Create main Verifier class</name>
  <files>src/rlm/verification/verifier.ts</files>
  <action>
Create verifier.ts implementing the main Verifier class (VER-01 orchestration):

```typescript
import type { VerificationResult, VerifierConfig, CheckResult, DEFAULT_VERIFIER_CONFIG } from './types.js';
import { typecheckFiles, runTests, scanImpact } from './checks/index.js';
import { ClaimExtractor } from './claims/extractor.js';
import { checkEvidenceCoverage, generateRefinementQuery } from './claims/coverage.js';
import type { Evidence } from '../engine/types.js';
```

**Class: Verifier**

Constructor:
- config: VerifierConfig (use DEFAULT_VERIFIER_CONFIG as default)
- claimExtractor: ClaimExtractor instance

Methods:

1. **async verify(response: string, evidence: Evidence[], changedFiles?: string[]): Promise<VerificationResult>**
   FIRE-style verification:
   a. Extract atomic claims from response
   b. Check evidence coverage
   c. Run enabled checks:
      - If changedFiles provided and enableTypecheck → typecheckFiles(changedFiles)
      - If changedFiles provided and enableTests → runTestsForAffectedFiles(changedFiles)
      - If changedFiles provided and enableImpactScan → scanImpact for each file
   d. Calculate overall confidence:
      - Base: evidence coverage ratio
      - Penalty: -0.2 per failed check
      - Bonus: +0.1 if all checks pass
   e. Determine if confident (overall >= config.confidenceThreshold)
   f. If not confident, generate refinement query
   g. Return VerificationResult

2. **async verifyWithConfidence(response: string, evidence: Evidence[], threshold?: number): Promise<VerificationResult>**
   Convenience wrapper that uses custom threshold.

3. **configure(config: Partial<VerifierConfig>): void**
   Update verifier configuration.

Private helpers:
- aggregateErrors(checks: CheckResult[]): VerificationError[]
- calculateConfidence(coverage: CoverageResult, checks: CheckResult[]): number
  </action>
  <verify>new Verifier().verify("Response text", evidence) returns VerificationResult with confident boolean</verify>
  <done>Verifier class orchestrating all checks with FIRE-style confidence</done>
</task>

<task type="auto">
  <name>Task 3: Integrate Verifier with RLMDispatcher (VER-03)</name>
  <files>src/rlm/engine/dispatcher.ts</files>
  <action>
Update dispatcher.ts to integrate verification with FIRE-style recursive refinement:

Add imports:
```typescript
import { Verifier, type VerificationResult } from '../verification/index.js';
```

Update DispatcherConfig:
```typescript
interface DispatcherConfig {
  // ... existing fields
  verifier?: Partial<VerifierConfig>;
  enableVerification: boolean; // default: true
}
```

Update VerifiedResult:
```typescript
interface VerifiedResult {
  // ... existing fields
  verification?: VerificationResult; // Add verification details
}
```

Modify dispatch() method:
1. After query returns response, create Verifier instance (if enableVerification)
2. Call verifier.verify(response, evidence)
3. If verification.confident = false AND canRecurse:
   a. Use verification.suggestedRefinement as new query
   b. Track error types to avoid infinite loops (FIRE pattern)
   c. If same error repeats, abort with partial result
   d. Recurse with refined query
4. Add verification result to VerifiedResult

Add method:
**private shouldRecurseForVerification(current: VerificationResult, previous?: VerificationResult): boolean**
- Return false if same errors repeat (prevents infinite loops)
- Return false if confidence improved less than 0.05 (diminishing returns)
- Return true if confidence below threshold and errors are new

This implements VER-03: Recursive refinement on verification failure.
  </action>
  <verify>dispatch() with failing verification triggers recursion attempt</verify>
  <done>RLMDispatcher integrates verification with FIRE-style recursion (VER-03)</done>
</task>

<task type="auto">
  <name>Task 4: Update module exports</name>
  <files>src/rlm/verification/index.ts, src/rlm/index.ts</files>
  <action>
Update src/rlm/verification/index.ts to export all Phase 3 modules:

```typescript
/**
 * RLM Verification Module
 *
 * Evidence validation and recursive refinement (Phase 3).
 * VER-01: Verifier with checks (typecheck, test, impact)
 * VER-02: Evidence coverage checking
 * VER-03: Recursive refinement on failure
 */

// Types
export * from './types.js';

// Claim extraction (VER-02 foundation)
export { ClaimExtractor } from './claims/extractor.js';
export { checkEvidenceCoverage, generateRefinementQuery, type CoverageResult } from './claims/coverage.js';

// Verification checks (VER-01)
export * from './checks/index.js';

// Main Verifier class
export { Verifier } from './verifier.js';
```

Update src/rlm/index.ts to include Phase 3 exports:

Add section comment and exports:
```typescript
// Phase 3: Verification Loop (VER-01, VER-02, VER-03)
export {
  Verifier,
  ClaimExtractor,
  checkEvidenceCoverage,
  typecheckFiles,
  runTests,
  scanImpact,
  type VerificationResult,
  type AtomicClaim,
  type CheckResult,
  type CoverageResult,
} from './verification/index.js';
```
  </action>
  <verify>Can import: `import { Verifier, ClaimExtractor, typecheckFiles } from 'src/rlm/index.js'`</verify>
  <done>All Phase 3 modules exported from main RLM index</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build:rlm` compiles all Phase 3 modules
- [ ] Verifier.verify() returns VerificationResult with confidence
- [ ] Evidence coverage identifies gaps in claim support
- [ ] RLMDispatcher triggers recursion on low confidence
- [ ] Infinite loop prevention (same errors don't recurse)
- [ ] All exports available from src/rlm/index.ts
</verification>

<success_criteria>
- VER-01: Verifier class orchestrates typecheck, test, impact checks
- VER-02: Evidence coverage checking with gap analysis
- VER-03: FIRE-style recursive refinement on verification failure
- Infinite loop prevention via error tracking
- Complete Phase 3 exports from main index
</success_criteria>

<output>
After completion, create `.planning/phases/03-verification-loop/03-03-SUMMARY.md`
</output>
