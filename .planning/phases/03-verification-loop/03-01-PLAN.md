---
phase: 03-verification-loop
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/rlm/verification/types.ts, src/rlm/verification/claims/extractor.ts, src/rlm/verification/index.ts]
autonomous: true
---

<objective>
Create verification types and NLP-based claim extraction for atomic decomposition.

Purpose: Foundation types for verification system and enhanced claim extraction using compromise.js (VER-02 foundation).
Output: Verification types and ClaimExtractor using NLP instead of basic regex splitting.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-verification-loop/03-RESEARCH.md

# Existing types to extend
@src/rlm/engine/types.ts
@src/rlm/evidence/tracker.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install compromise.js and create verification types</name>
  <files>src/rlm/verification/types.ts</files>
  <action>
First, install compromise for NLP:
```bash
npm install compromise
npm install -D @types/compromise
```

Then create src/rlm/verification/ directory and types.ts with:

1. **CheckType** enum: 'typecheck' | 'test' | 'impact'
2. **CheckResult** interface:
   - type: CheckType
   - passed: boolean
   - errors: Array<{ message: string; file?: string; line?: number }>
   - duration: number (ms)
3. **VerificationResult** interface (FIRE pattern):
   - confident: boolean
   - overallConfidence: number (0-1)
   - checks: CheckResult[]
   - errors: VerificationError[]
   - suggestedRefinement?: string (for recursion)
4. **VerificationError** interface:
   - type: CheckType
   - message: string
   - file?: string
   - line?: number
   - severity: 'error' | 'warning'
5. **AtomicClaim** interface (Claimify pattern):
   - text: string
   - verifiable: boolean
   - context: string
   - sourcePosition: number
   - chunkIds: string[] (linked evidence)
6. **VerifierConfig** interface:
   - enableTypecheck: boolean (default true)
   - enableTests: boolean (default true)
   - enableImpactScan: boolean (default true)
   - confidenceThreshold: number (default 0.7)
   - testTimeout: number (default 30000ms)

Export all types and a DEFAULT_VERIFIER_CONFIG constant.
  </action>
  <verify>npm run build:rlm compiles types without errors</verify>
  <done>Verification types defined with FIRE and Claimify patterns</done>
</task>

<task type="auto">
  <name>Task 2: Implement NLP-based claim extractor</name>
  <files>src/rlm/verification/claims/extractor.ts</files>
  <action>
Create src/rlm/verification/claims/ directory and extractor.ts implementing ClaimExtractor class:

```typescript
import nlp from 'compromise';
import type { AtomicClaim } from '../types.js';
```

**Class: ClaimExtractor**

Methods:
1. **extractAtomicClaims(response: string): AtomicClaim[]**
   - Use compromise to split into sentences: `nlp(response).sentences().json()`
   - Filter to verifiable content (skip opinions, recommendations)
   - Use pattern matching to detect non-verifiable: has('(think|believe|feel|suggest|recommend|might|could|should)')
   - Add context (surrounding text) for disambiguation
   - Return AtomicClaim[] with verifiable=true/false

2. **filterVerifiableClaims(claims: AtomicClaim[]): AtomicClaim[]**
   - Return only claims where verifiable=true
   - Skip questions (isQuestion check)
   - Skip meta-commentary ("In summary...", "As mentioned...")

3. **addChunkContext(claims: AtomicClaim[], chunkTexts: Map<string, string>): AtomicClaim[]**
   - For each claim, find which chunks contain similar text
   - Use simple substring matching (not semantic - that's retrieval's job)
   - Populate chunkIds field

Key patterns to filter OUT (non-verifiable):
- Opinion verbs: think, believe, feel, suggest, recommend
- Hedging: might, could, should, probably, perhaps
- Meta-commentary: "In summary", "As mentioned", "To clarify"
- Questions: sentences ending with ?

Keep claims that are:
- Factual statements about code behavior
- Assertions about file structure or function signatures
- Claims about what code does or doesn't do
  </action>
  <verify>Create test: extract claims from "The function returns null. I think it should return undefined." â†’ 1 verifiable claim</verify>
  <done>ClaimExtractor using compromise.js with verifiable content filtering</done>
</task>

<task type="auto">
  <name>Task 3: Create verification module index</name>
  <files>src/rlm/verification/index.ts</files>
  <action>
Create index.ts exporting verification types and ClaimExtractor:

```typescript
/**
 * RLM Verification Module
 *
 * Evidence validation and recursive refinement (Phase 3).
 * VER-01: Verifier with checks
 * VER-02: Evidence coverage
 * VER-03: Recursive refinement
 */

export * from './types.js';
export { ClaimExtractor } from './claims/extractor.js';
```

Note: Checks (typecheck, test, impact) added in Plan 03-02.
Verifier class added in Plan 03-03.
  </action>
  <verify>Can import: `import { AtomicClaim, ClaimExtractor } from './verification/index.js'`</verify>
  <done>Verification module exports configured</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] compromise package installed and @types/compromise available
- [ ] `npm run build:rlm` compiles all verification types
- [ ] ClaimExtractor.extractAtomicClaims() returns AtomicClaim[]
- [ ] Opinion/hedging statements filtered as non-verifiable
- [ ] Factual statements marked as verifiable
</verification>

<success_criteria>
- Verification types defined (CheckResult, VerificationResult, AtomicClaim)
- ClaimExtractor uses compromise.js for sentence segmentation
- Verifiable content filter distinguishes facts from opinions
- Foundation for VER-02 (evidence coverage checking)
</success_criteria>

<output>
After completion, create `.planning/phases/03-verification-loop/03-01-SUMMARY.md`
</output>
